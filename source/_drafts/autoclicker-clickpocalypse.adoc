---
OFF_title: "Autoclickers partie II – Clickpocalypse !"
title: "A"
date: 2017-04-28
tags: [javascript, incremental-games, intelligence-artificielle]
uscripts: ['js/incremental-games-autoclicker.js']
---

Exemple d'autoclicker pour un _idle game_ : CLICKPOCALYPSE II.

++++
<!-- more -->
++++

Je vais utiliser le code présenté dans mon article sur la
link:/2017/02/23/javascript-recursion-infinie/[récursion infinie en javascript]
pour montrer l'implémentation d'un petit programme jouant tout seul à
link:http://minmaxia.com/c2/[CLICKPOCKALYPSE 2], ou « c2 » pour les intimes.

Je vous conseille donc de lire l'article si ce n'est pas déjà fait, et de
démarrer une partie de c2 en parallèle si vous ne le conaissez pas. C'est un
_idle game_ donc il n'y a quasiment pas de gameplay, on peut :

- Rammasser des _loots_ ;
- choisir de nouvelles compétences pour nos personnages ;
- attaquer les chateaux quand les dongeons sont conquis ;
- activer des potions et des parchemins pour nous faciliter la tâche.

Nous allons automatiser les deux premières en guise d'exemple.

== Setup

J'ai développé cet autoclicker dans Chromium avec
https://tampermonkey.net/[Tampermonkey], disponible également pour Chrome et
Vivaldi. Il existe également pour Firefox mais je conseille plutôt
https://addons.mozilla.org/fr/firefox/addon/greasemonkey/[Greasemonkey].

Ces outils permettent d'ajouter automatiquement un ou plusieurs scripts sur une
page web, chargés automatiquement au démarrage de la page. Plus besoin de lancer
les scripts depuis la console comme on le faisait pour notre premier
autoclicker.

L'éditeur de code de Tampermonkey n'est pas des plus pratiques, on préfèrera
donc charger le script depuis le disque dur. Pour cela il faudra autoriser
l'accès au disque pour Tampermonkey dans la gestion des extensions du navigateur
: cocher « Autoriser l'accès aux URL de fichier ».

Ensuite il faudra quand même créer un script Tampermonkey, contenant simplement
une instruction pour charger le fichier depuis le disque.

Enfin, ces scripts s'exécutent dans une _sandbox_, c'est à dire un contexte
javascript différent de celui de la page web. Il faut donc leur donner
explicitement l'accès à notre objet `window` afin de pouvoir interagir avec la
page. Cela se fait via `@grant unsafeWindow` dans le _header_ de notre script.
Ensuite, on déclare nos variables `window` et `document`, notre code aura l'air
plus « habituel » et surtout, on pourra le tester directement dans la console.

Voici le script Tampermonkey. Notez l'instruction `@require`.

[source,javascript]
----
// ==UserScript==
// @name         Clickpocalypse 2 autoclick
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  try to take over the world!
// @author       You
// @match        http://minmaxia.com/c2/
// @grant        unsafeWindow
// @require      /Chemin/absolu/vers/votre autoclicker.js
// ==/UserScript==
----

Voici le header de notre fichier javascript présent sur le disque dur. Il est
important de saisir là aussi le header UserScript.

[source,javascript]
----
// ==UserScript==
// @name         Clickpocalypse 2 autoclick
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  try to take over the world!
// @author       You
// @match        http://minmaxia.com/c2/
// @grant        unsafeWindow
// ==/UserScript==
'use strict'

var window = unsafeWindow
var document = window.document
----













// == Définir les actions de l'autoclicker

// Je vais commencer par écrire ce que notre autoclicker pourra faire pour se
// renseigner sur l'état du jeu et interagir avec le jeu. Dans un second temps je
// décrirai comment mettre tout ça en place dans une boucle intelligente, une mini
// intelligence artificielle.

// === Attendre le chargement

// Si une sauvegarde du jeu est présente dans le cache du navigateur, le jeu
// calculer tout ce qui s'est passé dans les 16h au maximum suivant la sauvegarde.
// Pour ne pas interrompre ce processus, on va lancer notre autoclicker au sein
// d'une fonction `main` que l'on lancera une fois le chargement fini.

// Pour savoir si le chargement est en cours, on peut tester la présence d'un `div.offlineProgressBarContainer`.

// [source,javascript]
// ----
// function isGameReady() {
//   return document.querySelector('.offlineProgressBarContainer') === null
// }
// ----

// Il faut maitenant récupérer toutes les fonctions de clic que l'on souhaite
// utiliser.

// === Afficher les onglets

// Lorsque notre autolicker va acheter de nouvelles compétences pour nos
// personnages, on va d'abord cliquer sur l'onglet de ce personnage, afin de
// pouvoir visualiser les compétences qu'on achète. C'est plus sympa, mais surtout
// ça nous permet de voir facilement si notre code fonctionne !

// Aussi, quand il n'y a rien de disponible à acheter, on affichera le jeu plutôt
// que de rester sur le dernier onglet utilisé.

// Malheureusement, les `<a />` qui constituent ces onglets n'ont pas d'attribut
// `id` ou `class` individuels pour les sélectionner facilement. Il faut donc lire
// leur contenu (le texte du bouton) pour savoir à quoi correspond notre onglet.

// On parcourt donc les onglets dans une boucle. Pour ceux qui nous intéressent,
// c'est à dire l'onglet « Game » permettant d'afficher le jeu, et les feuilles de
// personnages, on stocke une référence vers la fonction de clic.

// Les onglets personnages affichent un nombre quand le personnage dispose de
// points de compétences. Par exemple, l'onglet du rogue contiendra `'Rogue 5'`
// dans ce cas, et simplement `'Rogue'` si aucun point de compétences n'est
// disponible. Par conséquent on utilise une expression régulière pour trouver
// notre onglet. Cela nous permet également de stocker une fonction renvoyant le
// nombre de points de compétences disponibles pour notre personnage, que l'on
// utilisera plus tard pour décider si on doit aller acheter ces points.

// [source,javascript]
// ----
// var tabs = document.querySelectorAll('.__TABS_WRAPPER_CLASS a')
//   .reduce(function(tabs, a) {
//     if (a.innerHTML === 'Game') {
//       tabs.game = return {type: 'game', click: a.onclick}
//     } else if (a.innerHTML.match(/(Pyro|Druid|Rogue|King|__TODO__)( [0-9]+)?/)) {
//       tabs.characters.push({
//         click: a.onclick,
//         skillpoints: function() {
//           var match = a.innerHTML.match(/([0-9]+)/)
//           return match ? Number(match[0]) : 0
//         }
//       })
//     }
//     return tabs
//   }, {characters: []})
// ----

// === Acheter des compétences

// On sait maintenant afficher les feuilles de personnages en cliquant sur ces
// onglets. Reste à interagir avec.

// Commençons par établir un lien entre nos onglets `characters` et les tableaux
// de compétences disponibles en jeu. L'onglet « Skills » est affiché par défaut
// donc on ne va pas rajouter une étape de clic dessus.

// == @todo
// skills utilisent mouseup()
// Attente du chargement
// Récupération des liens & boutons
// Lecture des points de compétence disponibles
// Orchestration
